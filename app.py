import base64
import json
import os
import mimetypes
import uuid
from typing import Optional
from fastapi import FastAPI, File, Form, UploadFile, HTTPException, Request, Header, Response
import uvicorn
from dotenv import load_dotenv
from fastapi.middleware.cors import CORSMiddleware
import shutil

# --- NEW FAL AI IMPORT ---
import fal_client

# --- PADDLE & FIREBASE INTEGRATION ---
from paddle_sdk import Client, Environment
from paddle_sdk.exceptions.request import PaddleException
from paddle_sdk.webhooks.signature import Signature
import firebase_admin
from firebase_admin import credentials, firestore
# --- END INTEGRATION IMPORTS ---


load_dotenv()

app = FastAPI(title="DreamAI API")

app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://dreamai-checkpoint.netlify.app", "http://localhost:8081", "http://localhost:3000", "https://vision-ai-tester.netlify.app"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

UPLOAD_DIR = "uploads"
OUTPUT_DIR = "outputs"
os.makedirs(UPLOAD_DIR, exist_ok=True)
os.makedirs(OUTPUT_DIR, exist_ok=True)

# Update the startup check to include the FAL_AI_KEY
if not all(os.environ.get(key) for key in ["PADDLE_API_KEY", "PADDLE_WEBHOOK_SECRET", "FIREBASE_DATABASE_URL", "FIREBASE_SERVICE_ACCOUNT_BASE64", "FAL_AI_KEY"]):
    raise ValueError("All required environment variables (Paddle, Firebase, Fal AI) must be set")

# Configure Fal AI client with the key
fal_client.api_key = os.environ.get("FAL_AI_KEY")

# --- PADDLE & FIREBASE INITIALIZATION (Unchanged) ---
paddle = Client(
    api_key=os.environ.get("PADDLE_API_KEY"),
    environment=Environment.sandbox,
)
try:
    firebase_sa_base64 = os.environ.get("FIREBASE_SERVICE_ACCOUNT_BASE64")
    firebase_sa_decoded = base64.b64decode(firebase_sa_base64).decode('utf-8')
    firebase_sa_dict = json.loads(firebase_sa_decoded)
    cred = credentials.Certificate(firebase_sa_dict)
    firebase_admin.initialize_app(cred, {'databaseURL': os.environ.get("FIREBASE_DATABASE_URL")})
    db = firestore.client()
    print("Firebase Admin SDK initialized successfully from Base64 environment variable.")
except (ValueError, TypeError, json.JSONDecodeError) as e:
    raise ValueError(f"Error decoding or parsing Firebase service account from environment variable: {e}")
# --- END INITIALIZATION ---


# =================================================================================
# === REFACTORED /generate/ ENDPOINT FOR FAL AI ===================================
# =================================================================================
@app.post("/generate/")
async def generate_image(
    image1: UploadFile = File(...),
    # The payload can still contain these, but we will ignore them
    image2: Optional[UploadFile] = File(None),
    prompt: str = Form(...),
    temperature: float = Form(1.0), # temperature is not a direct param for FLUX
    top_p: float = Form(0.95),       # top_p is not a direct param for FLUX
    top_k: int = Form(40),         # top_k is not a direct param for FLUX
):
    """
    Generate an image using Fal AI's FLUX model based on ONE input image and a prompt.
    This endpoint maintains the original payload structure for frontend compatibility.
    """
    # Ensure an image was actually sent
    if not image1 or not image1.file:
        raise HTTPException(status_code=400, detail="An image file is required.")

    try:
        # Read the image bytes directly from the upload stream into memory.
        # This is more efficient than saving to disk first.
        image_bytes = await image1.read()
        
        # Ensure the file type is one Fal AI can handle
        allowed_types = ["image/jpeg", "image/png", "image/webp"]
        if image1.content_type not in allowed_types:
            raise HTTPException(
                status_code=415, 
                detail=f"Unsupported image type: {image1.content_type}. Please use JPEG, PNG, or WebP."
            )

        # Call the Fal AI model using fal_client.run for a direct response
        # We wrap the image bytes using fal_client's helper class
        result = fal_client.run(
            "fal-ai/flux-pro/kontext",
            arguments={
                "prompt": prompt,
                "image": fal_client.Image.from_bytes(image_bytes, format=image1.content_type.split('/')[1]),
                # Default values for FLUX can be set here
                "guidance_scale": 3.5,
                "num_images": 1,
                "output_format": "jpeg", # The frontend expects an image
            },
        )

        # Process the response from Fal AI
        if not result or "images" not in result or len(result["images"]) == 0:
            raise HTTPException(status_code=500, detail="No image was generated by the model.")
        
        # Extract the generated image data
        generated_image = result["images"][0]
        image_content_bytes = generated_image["content"]
        image_media_type = generated_image["content_type"]

        # Return the image bytes directly in the response body.
        # FastAPI's Response object is used for in-memory content.
        return Response(content=image_content_bytes, media_type=image_media_type)

    except fal_client.FALServerException as e:
        print(f"Fal AI Server Error: {e}")
        raise HTTPException(status_code=503, detail=f"The image generation service failed: {e}")
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        import traceback
        traceback.print_exc()
        raise HTTPException(status_code=500, detail="An internal server error occurred.")
# =================================================================================
# === END OF REFACTORED ENDPOINT ==================================================
# =================================================================================


# --- ALL OTHER ENDPOINTS (products, checkouts, webhooks, health) remain UNCHANGED ---
@app.get("/products")
async def get_products():
    try:
        product_response = paddle.products.list(params={'status': 'active', 'include': 'prices'})
        products = list(product_response)
        return {"data": products}
    except PaddleException as e:
        raise HTTPException(status_code=500, detail=f"Paddle API error: {e}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"An internal error occurred: {e}")


@app.post("/create-checkout")
async def create_checkout(request: Request):
    body = await request.json()
    price_id = body.get('priceId')
    user_id = body.get('userId')
    if not price_id or not user_id:
        raise HTTPException(status_code=400, detail="priceId and userId are required")
    try:
        user_doc = db.collection('users').document(user_id).get()
        paddle_customer_id = user_doc.to_dict().get('paddle_customer_id') if user_doc.exists else None
        transaction_data = {
            "items": [{"price_id": price_id, "quantity": 1}],
            "customer_id": paddle_customer_id,
            "custom_data": { "firebase_uid": user_id, },
            "success_url": "https://dreamai-checkpoint.netlify.app/payment-success",
        }
        transaction = paddle.transactions.create(transaction_data)
        return {"checkout_url": transaction.checkout.url}
    except PaddleException as e:
        raise HTTPException(status_code=500, detail=f"Paddle API error: {e}")
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"An internal error occurred: {e}")


@app.post("/create-customer-portal")
async def create_customer_portal(request: Request):
    body = await request.json()
    user_id = body.get('userId')
    if not user_id:
        raise HTTPException(status_code=400, detail="userId is required")
    user_doc = db.collection('users').document(user_id).get()
    if not user_doc.exists or not user_doc.to_dict().get('paddle_customer_id'):
        raise HTTPException(status_code=404, detail="User has no subscription to manage.")
    paddle_customer_id = user_doc.to_dict().get('paddle_customer_id')
    try:
        portal_link = paddle.customer_portal.create(paddle_customer_id)
        return {"portal_url": portal_link.url}
    except PaddleException as e:
        raise HTTPException(status_code=500, detail=f"Paddle API error: {e}")


@app.post("/paddle-webhook")
async def paddle_webhook(request: Request, paddle_signature: str = Header(None)):
    if not paddle_signature:
        raise HTTPException(status_code=400, detail="Missing Paddle-Signature header")
    try:
        request_body = await request.body()
        webhook_secret = os.environ.get("PADDLE_WEBHOOK_SECRET")
        Signature.verify(request_body, paddle_signature, webhook_secret)
        event_data = await request.json()
        event_type = event_data.get("event_type")
        data = event_data.get("data")
        if event_type == "transaction.completed":
            firebase_uid = data.get("custom_data", {}).get("firebase_uid")
            if not firebase_uid: return JSONResponse(status_code=400, content={"error": "Missing firebase_uid"})
            user_ref = db.collection('users').document(firebase_uid)
            paddle_customer_id = data.get("customer_id")
            if paddle_customer_id:
                user_ref.set({"paddle_customer_id": paddle_customer_id}, merge=True)
            for item in data.get("items", []):
                product_id = item.get("product", {}).get("id")
                product_details = paddle.products.get(product_id)
                product_type = product_details.custom_data.get("type")
                if product_type == "credits":
                    credits_to_add = product_details.custom_data.get("credits", 0)
                    user_ref.update({"credits": firestore.Increment(credits_to_add)})
                    print(f"Added {credits_to_add} credits to user {firebase_uid}")
                elif product_type == "subscription":
                    user_ref.set({
                        "premium_status": product_details.name,
                        "subscription_id": data.get("subscription_id"),
                        "subscription_status": "active"
                    }, merge=True)
                    print(f"ACTIVATED subscription for user {firebase_uid}")
        elif event_type == "subscription.canceled":
            customer_id = data.get("customer_id")
            users_query = db.collection('users').where('paddle_customer_id', '==', customer_id).limit(1).stream()
            for user_doc in users_query:
                user_ref = user_doc.reference
                user_ref.update({"premium_status": None, "subscription_status": "canceled"})
                print(f"CANCELED subscription for user {user_doc.id}")
        elif event_type == "subscription.updated" or event_type == "subscription.past_due":
            customer_id = data.get("customer_id")
            subscription_status = data.get("status")
            users_query = db.collection('users').where('paddle_customer_id', '==', customer_id).limit(1).stream()
            for user_doc in users_query:
                user_ref = user_doc.reference
                if subscription_status != 'active':
                    user_ref.update({"premium_status": None, "subscription_status": subscription_status})
                    print(f"DEACTIVATED subscription for user {user_doc.id} due to status: {subscription_status}")
                else:
                    user_ref.update({"subscription_status": "active"})
        return {"status": "received"}
    except ValueError:
        raise HTTPException(status_code=401, detail="Invalid signature")
    except Exception as e:
        print(f"Error processing webhook: {e}")
        raise HTTPException(status_code=500, detail="Internal server error")


@app.get("/health")
async def health_check():
    return {"status": "healthy"}
