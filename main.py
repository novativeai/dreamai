import os
import mimetypes
import uuid
from typing import Optional
from fastapi import FastAPI, File, Form, UploadFile, HTTPException
from fastapi.responses import FileResponse, JSONResponse
from google import genai
from google.genai import types

app = FastAPI(title="Gemini Image Generation API")

# Directory to store uploaded and generated files
UPLOAD_DIR = "uploads"
OUTPUT_DIR = "outputs"

# Create directories if they don't exist
os.makedirs(UPLOAD_DIR, exist_ok=True)
os.makedirs(OUTPUT_DIR, exist_ok=True)

# Check if API key is set
if not os.environ.get("GEMINI_API_KEY"):
    raise ValueError("GEMINI_API_KEY environment variable must be set")

def save_file(upload_file: UploadFile) -> str:
    """Save an uploaded file to disk and return the path"""
    file_path = os.path.join(UPLOAD_DIR, f"{uuid.uuid4()}_{upload_file.filename}")
    with open(file_path, "wb") as f:
        f.write(upload_file.file.read())
    return file_path

@app.post("/generate/")
async def generate_image(
    image1: UploadFile = File(...),
    image2: UploadFile = File(...),
    prompt: str = Form(...),
    temperature: float = Form(1.0),
    top_p: float = Form(0.95),
    top_k: int = Form(40),
):
    """
    Generate an image using Gemini API based on two input images and a text prompt.
    
    - **image1**: First input image
    - **image2**: Second input image
    - **prompt**: Text description of what to generate
    - **temperature**: Controls randomness (0.0-1.0)
    - **top_p**: Nucleus sampling parameter (0.0-1.0)
    - **top_k**: Top-k sampling parameter
    """
    try:
        # Initialize Gemini client
        client = genai.Client(
            api_key=os.environ.get("GEMINI_API_KEY"),
        )
        
        # Save uploaded files
        image1_path = save_file(image1)
        image2_path = save_file(image2)
        
        # Upload files to Gemini
        file1 = client.files.upload(file=image1_path)
        file2 = client.files.upload(file=image2_path)
        
        # Set up the model request
        model = "gemini-2.0-flash-exp-image-generation"
        contents = [
            types.Content(
                role="user",
                parts=[
                    types.Part.from_uri(
                        file_uri=file1.uri,
                        mime_type=file1.mime_type,
                    ),
                    types.Part.from_uri(
                        file_uri=file2.uri,
                        mime_type=file2.mime_type,
                    ),
                    types.Part.from_text(text=prompt),
                ],
            ),
        ]
        
        generate_content_config = types.GenerateContentConfig(
            temperature=temperature,
            top_p=top_p,
            top_k=top_k,
            max_output_tokens=8192,
            response_modalities=["image", "text"],
        )
        
        # Generate content
        response = client.models.generate_content(
            model=model,
            contents=contents,
            config=generate_content_config,
        )
        
        # Process the response
        if not response.candidates or not response.candidates[0].content or not response.candidates[0].content.parts:
            raise HTTPException(status_code=500, detail="No content generated by the model")
        
        # Handle image in response
        for part in response.candidates[0].content.parts:
            if hasattr(part, 'inline_data') and part.inline_data:
                # Save the generated image
                output_filename = f"generated_{uuid.uuid4()}"
                file_extension = mimetypes.guess_extension(part.inline_data.mime_type) or ".png"
                output_file_path = os.path.join(OUTPUT_DIR, f"{output_filename}{file_extension}")
                
                with open(output_file_path, "wb") as f:
                    f.write(part.inline_data.data)
                
                # Clean up temporary files
                os.remove(image1_path)
                os.remove(image2_path)
                
                return FileResponse(
                    path=output_file_path,
                    media_type=part.inline_data.mime_type,
                    filename=f"generated_image{file_extension}"
                )
        
        # Handle text-only response
        text_response = response.candidates[0].content.parts[0].text if hasattr(response.candidates[0].content.parts[0], 'text') else "No text response"
        
        # Clean up temporary files
        os.remove(image1_path)
        os.remove(image2_path)
        
        return {"message": "Generation completed", "text": text_response}
            
    except Exception as e:
        # Clean up any temporary files if they exist
        for path in [image1_path, image2_path]:
            if 'path' in locals() and os.path.exists(path):
                os.remove(path)
                
        return JSONResponse(
            status_code=500,
            content={"error": str(e)},
        )

@app.get("/health")
async def health_check():
    """Health check endpoint to verify the API is running"""
    return {"status": "healthy"}
